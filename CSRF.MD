## üîí Melhoria Futura: CSRF Avan√ßado

‚ö†Ô∏è CSRF - Prote√ß√£o B√°sica Implementada (Baixa Prioridade)

Status:

- ‚úÖ sameSite: "strict" (bloqueia 95% dos ataques)
- ‚úÖ httpOnly + secure cookies
- ‚úÖ X-Frame-Options (anti-clickjacking)
- ‚ö†Ô∏è Melhorias adicionais pendentes (n√£o cr√≠ticas)

Decis√£o:

- Deixar para Fase 2 (p√≥s-produ√ß√£o)
- Implementar antes de: subdom√≠nios, APIs p√∫blicas, auditoria
- C√≥digo preparado dispon√≠vel

Risco Atual: BAIXO (ambiente controlado)

### Status Atual:

‚úÖ Prote√ß√£o b√°sica implementada (sameSite: strict + httpOnly)
‚ö†Ô∏è Prote√ß√£o avan√ßada pendente

### O que falta:

1. Domain expl√≠cito no cookie (evita subdom√≠nios)
2. Valida√ß√£o de Origin/Referer header
3. Middleware global para todas as APIs
4. (Opcional) CSRF Token (Double Submit Cookie)

### Quando implementar:

- [ ] Antes de adicionar subdom√≠nios (ex: blog.countifly.com)
- [ ] Antes de expor API publicamente
- [ ] Se adicionar integra√ß√£o com terceiros
- [ ] Se passar por auditoria de seguran√ßa

### Estimativa:

- Tempo: 20-30 minutos
- Complexidade: Baixa
- Impacto: Defesa em profundidade
- Arquivo: `/lib/csrf.ts` + ajustes em cookies

## üìä **AN√ÅLISE DA PROTE√á√ÉO CSRF ATUAL (17/02/2026):**

### **‚úÖ O QUE J√Å EST√Å IMPLEMENTADO (Linha 67 do `auth/route.ts`):**

```typescript
sameSite: "strict", // ‚úÖ Protege contra ataques CSRF
```

**Isso J√Å oferece prote√ß√£o contra CSRF tradicional!**

---

## üõ°Ô∏è **COMO `sameSite: "strict"` PROTEGE:**

### **Cen√°rio de Ataque Bloqueado:**

```html
<!-- Site malicioso: evil.com -->
<form action="https://countifly.com/api/inventory/import" method="POST">
  <input type="hidden" name="data" value='[{"codigo":"12345","qtd":-999}]' />
</form>
<script>
  document.forms[0].submit(); // Tenta fazer POST para Countifly
</script>
```

**Resultado com `sameSite: "strict"`:**

- ‚ùå Cookie `authToken` **N√ÉO √© enviado** (browser bloqueia)
- ‚ùå Request chega sem autentica√ß√£o
- ‚ùå API retorna 401 Unauthorized
- ‚úÖ **Ataque CSRF bloqueado!**

---

## ‚ö†Ô∏è **PROBLEMA: Vulnerabilidades Residuais**

### **1. Ataque de Subdom√≠nio Comprometido**

**Cen√°rio:**

- Voc√™ tem `countifly.com`
- Atacante compromete `blog.countifly.com` (subdom√≠nio)

**Com `sameSite: "strict"` atual:**

```typescript
// Cookie configurado assim:
{
  domain: undefined, // ‚ùå Padr√£o: dom√≠nio atual
  sameSite: "strict"
}
```

**Problema:**

- Se `domain` n√£o for explicitamente definido, browser pode considerar subdom√≠nios
- Atacante em `blog.countifly.com` pode fazer requests para `countifly.com` e **cookie PODE ser enviado** (depende do browser)

---

### **2. Ataque de Clickjacking (Mesmo com sameSite)**

**Cen√°rio:**

```html
<!-- Site malicioso -->
<iframe src="https://countifly.com/admin/users" style="opacity:0"></iframe>
<button onclick="clickIframe()">Ganhe R$1000!</button>
```

**Resultado:**

- Se usu√°rio clica, pode acionar a√ß√£o no iframe
- `sameSite: strict` N√ÉO protege porque n√£o √© "cross-site request", √© "cross-origin embedding"

---

## üõ°Ô∏è **SOLU√á√ÉO: Camadas Adicionais de Prote√ß√£o**

### **Estrat√©gia de Defesa em Profundidade:**

```
Camada 1: sameSite: "strict" ‚úÖ (J√° tem)
Camada 2: domain expl√≠cito ‚ö†Ô∏è (Adicionar)
Camada 3: X-Frame-Options ‚úÖ (J√° tem no next.config)
Camada 4: Origin/Referer check ‚ö†Ô∏è (Adicionar)
Camada 5: CSRF Token (Opcional - m√°xima seguran√ßa)
```

---

## üîß **IMPLEMENTA√á√ÉO: Camada 2 + 4**

### **üìù 1. Melhorar Configura√ß√£o de Cookie (Camada 2)**

**Arquivo: `app/api/auth/route.ts` (linha 62-68)**

**‚ùå ANTES:**

```typescript
cookieStore.set("authToken", token, {
  httpOnly: true,
  secure: process.env.NODE_ENV === "production",
  sameSite: "strict",
  maxAge: 60 * 60 * 24,
  path: "/",
});
```

**‚úÖ DEPOIS:**

```typescript
cookieStore.set("authToken", token, {
  httpOnly: true,
  secure: process.env.NODE_ENV === "production",
  sameSite: "strict",
  maxAge: 60 * 60 * 24,
  path: "/",
  domain:
    process.env.NODE_ENV === "production"
      ? process.env.NEXT_PUBLIC_DOMAIN // ‚úÖ Ex: "countifly.com" (sem subdom√≠nios)
      : undefined, // ‚úÖ Localhost n√£o precisa
});
```

**Adicione no `.env`:**

```env
NEXT_PUBLIC_DOMAIN=countifly.com
```

---

### **üìù 2. Adicionar Verifica√ß√£o de Origin (Camada 4)**

**Crie: `lib/csrf.ts`**

```typescript
// lib/csrf.ts
/**
 * Prote√ß√£o adicional contra CSRF atrav√©s de verifica√ß√£o de Origin/Referer.
 * Funciona em conjunto com sameSite: "strict" para defesa em profundidade.
 */

import { NextRequest } from "next/server";
import { AppError } from "@/lib/auth";

const ALLOWED_ORIGINS = process.env.ALLOWED_ORIGINS?.split(",") || [
  "http://localhost:3000",
  "https://countifly.com",
  "https://www.countifly.com",
];

export class CSRFError extends AppError {
  constructor(message = "Requisi√ß√£o bloqueada por verifica√ß√£o de origem.") {
    super(message, 403);
  }
}

/**
 * Valida se a requisi√ß√£o vem de uma origem permitida.
 * Deve ser chamada em rotas que modificam dados (POST, PUT, DELETE, PATCH).
 */
export function validateOrigin(request: NextRequest): void {
  // Permite OPTIONS (preflight CORS)
  if (request.method === "OPTIONS") return;

  // Apenas valida m√©todos que modificam dados
  const safeMethods = ["GET", "HEAD"];
  if (safeMethods.includes(request.method)) return;

  const origin = request.headers.get("origin");
  const referer = request.headers.get("referer");

  // Se tiver Origin (requisi√ß√µes AJAX/Fetch), valida
  if (origin) {
    if (!ALLOWED_ORIGINS.includes(origin)) {
      console.warn(`[CSRF] Origin bloqueado: ${origin}`);
      throw new CSRFError(`Origem n√£o permitida: ${origin}`);
    }
    return; // V√°lido
  }

  // Se n√£o tiver Origin, valida Referer (form submissions)
  if (referer) {
    const refererUrl = new URL(referer);
    const refererOrigin = refererUrl.origin;

    if (!ALLOWED_ORIGINS.includes(refererOrigin)) {
      console.warn(`[CSRF] Referer bloqueado: ${referer}`);
      throw new CSRFError(`Referer n√£o permitido: ${referer}`);
    }
    return; // V√°lido
  }

  // Se n√£o tem nem Origin nem Referer, bloqueia (suspeito)
  console.warn(
    `[CSRF] Requisi√ß√£o sem Origin/Referer: ${request.method} ${request.url}`,
  );
  throw new CSRFError("Requisi√ß√£o sem cabe√ßalhos de origem.");
}
```

**Adicione no `.env`:**

```env
ALLOWED_ORIGINS=http://localhost:3000,https://countifly.com,https://www.countifly.com
```

---

### **üìù 3. Aplicar em Rotas Cr√≠ticas**

**Exemplo: `app/api/inventory/import/route.ts`**

```typescript
import { NextRequest, NextResponse } from "next/server";
import { validateOrigin } from "@/lib/csrf"; // ‚úÖ Importa valida√ß√£o

export async function POST(request: NextRequest) {
  try {
    validateOrigin(request); // ‚úÖ Valida origem ANTES de processar

    // ... resto do c√≥digo existente
  } catch (error: any) {
    if (error instanceof CSRFError) {
      return NextResponse.json(
        { error: error.message },
        { status: error.statusCode },
      );
    }
    throw error;
  }
}
```

---

### **üìù 4. Aplicar em TODAS as Rotas Autenticadas (Middleware Global)**

**Melhor ainda: Adicionar no middleware existente**

**Arquivo: `middleware.ts` (se voc√™ tiver)**

```typescript
import { NextRequest, NextResponse } from "next/server";
import { validateOrigin, CSRFError } from "@/lib/csrf";

export function middleware(request: NextRequest) {
  try {
    // ‚úÖ Valida Origin em todas as rotas /api/*
    if (request.nextUrl.pathname.startsWith("/api/")) {
      validateOrigin(request);
    }

    return NextResponse.next();
  } catch (error: any) {
    if (error instanceof CSRFError) {
      return NextResponse.json(
        { error: error.message },
        { status: error.statusCode },
      );
    }

    return NextResponse.json({ error: "Erro interno" }, { status: 500 });
  }
}

export const config = {
  matcher: "/api/:path*",
};
```

---

## üìä **COMPARA√á√ÉO: Antes vs Depois**

| Ataque                          | ANTES (s√≥ sameSite)            | DEPOIS (completo)               |
| ------------------------------- | ------------------------------ | ------------------------------- |
| **CSRF tradicional (evil.com)** | ‚úÖ Bloqueado                   | ‚úÖ Bloqueado                    |
| **Subdom√≠nio comprometido**     | ‚ö†Ô∏è Parcial                     | ‚úÖ Bloqueado (domain expl√≠cito) |
| **Request sem Origin/Referer**  | ‚ö†Ô∏è Permitido                   | ‚úÖ Bloqueado                    |
| **Clickjacking**                | ‚úÖ Bloqueado (X-Frame-Options) | ‚úÖ Bloqueado                    |
| **Origin spoofing**             | ‚ùå N√£o verifica                | ‚úÖ Validado                     |

---

## ‚úÖ **CHECKLIST DE IMPLEMENTA√á√ÉO:**

### **N√≠vel 1: B√°sico**

- [x] `sameSite: "strict"`
- [x] `httpOnly: true`
- [x] `secure: true` (produ√ß√£o)
- [x] `X-Frame-Options: DENY`

### **N√≠vel 2: Recomendado (adicionar)**

- [ ] `domain` expl√≠cito no cookie
- [ ] Valida√ß√£o de Origin/Referer
- [ ] Middleware global para todas as APIs
- [ ] Logging de tentativas bloqueadas

### **N√≠vel 3: M√°xima Seguran√ßa (opcional)**

- [ ] CSRF Token (Double Submit Cookie)
- [ ] Rate limiting por IP
- [ ] Captcha em a√ß√µes sens√≠veis

---

## üéØ **RECOMENDA√á√ÉO:**

**Para aplica√ß√£o de invent√°rio:**

‚úÖ **Implemente N√≠vel 2** (adicionar Origin check + domain expl√≠cito)

**Raz√£o:**

- `sameSite: strict` j√° protege 95% dos casos
- Origin check adiciona camada extra contra subdom√≠nios
- CSRF Token seria "overkill" para seu uso
